# oneFourSeven/serializers.py
from rest_framework import serializers
from django.contrib.auth.models import User # Default Django user model

# Import your application's models
from .models import Event, Player, Ranking, MatchesOfAnEvent

class PlayerSerializer(serializers.ModelSerializer):
    """
    Serializes Player model instances.
    Includes all fields defined in the Player model.
    """
    class Meta:
        model = Player
        fields = '__all__' # Include all fields by default


class RankingSerializer(serializers.ModelSerializer):
    """
    Serializes Ranking model instances.
    Includes the standard fields and adds a read-only 'player_name' field.
    """
    # Read-only field to display the player's name alongside the ID
    player_name = serializers.SerializerMethodField(read_only=True)

    # Note: By default, DRF serializes ForeignKey fields (like 'Player')
    # using their primary key (Player.ID in this case). This is usually desired.
    # The 'Player' field in the output JSON will contain the player's ID.

    class Meta:
        model = Ranking
        # List all fields to be included in the serialized output
        fields = [
            'ID',           # Ranking entry API ID (PK of Ranking model)
            'Position',
            'Player',       # Foreign Key to Player (will output Player's PK/ID)
            'player_name',  # Added read-only field for convenience
            'Season',
            'Sum',          # Points or Money sum
            'Type',         # Ranking type (e.g., MoneyRankings)
        ]
        # Specify fields that are generated by the serializer and not directly mapped
        read_only_fields = ['player_name']

    def get_player_name(self, obj: Ranking) -> str:
        """
        Returns the string representation of the linked Player.

        Args:
            obj: The Ranking instance being serialized.

        Returns:
            The player's full name or an identifier if the player is not linked/found.

        Note: For efficiency, ensure the queryset used in the view calling this
              serializer uses `select_related('Player')` to avoid N+1 database queries.
        """
        if obj.Player:
            # Use the Player model's __str__ method for the name
            return str(obj.Player)
        # Fallback if Player FK is null but the ID might still be available (less common with SET_NULL)
        elif hasattr(obj, 'Player_id') and obj.Player_id:
             return f"Player ID {obj.Player_id} (Not Found)"
        return "N/A" # Or "Unknown Player"


class EventSerializer(serializers.ModelSerializer):
    """
    Serializes Event model instances.
    Includes all fields defined in the Event model plus computed prize money.
    """
    winner_prize_money = serializers.SerializerMethodField(read_only=True)
    
    class Meta:
        model = Event
        fields = '__all__'
    
    def get_winner_prize_money(self, obj):
        """Get the winner's prize money for the tournament."""
        return obj.get_winner_prize_money()


class MatchesOfAnEventSerializer(serializers.ModelSerializer):
    """
    Serializes MatchesOfAnEvent model instances.

    Note: Player names ('player1_name', 'player2_name') are typically added
          in the view (`views.py`) after efficiently fetching player data in bulk,
          rather than using SerializerMethodFields here to avoid N+1 query problems.
          The view constructs the final response dictionary including these names.
    """
    # Example of adding player names via serializer (generally less efficient):
    # player1_name = serializers.SerializerMethodField(read_only=True)
    # player2_name = serializers.SerializerMethodField(read_only=True)

    class Meta:
        model = MatchesOfAnEvent
        fields = '__all__' # Include all model fields by default
        # If adding method fields:
        # fields = list(serializers.ModelSerializer.Meta.fields) + ['player1_name', 'player2_name']
        # read_only_fields = ['player1_name', 'player2_name']

    # --- Example methods if adding names via serializer (INEFFICIENT - Use View Instead) ---
    # def _get_player_name_from_id(self, player_id):
    #     if not player_id: return "TBD"
    #     # This causes N+1 queries if used in a list view!
    #     try:
    #         player = Player.objects.get(ID=player_id)
    #         return str(player)
    #     except Player.DoesNotExist:
    #         return f"Unknown Player ({player_id})"
    #     except Exception as e:
    #          logger.error(f"Error fetching player name for ID {player_id}: {e}")
    #          return f"Error ({player_id})"

    # def get_player1_name(self, obj: MatchesOfAnEvent):
    #     return self._get_player_name_from_id(obj.Player1ID)

    # def get_player2_name(self, obj: MatchesOfAnEvent):
    #      return self._get_player_name_from_id(obj.Player2ID)
    # ------------------------------------------------------------------------------------


class UserSerializer(serializers.ModelSerializer):
    """
    Serializes the default Django User model.
    Excludes sensitive fields like password hash.
    """
    class Meta:
        model = User
        # Explicitly list fields to include for security
        fields = [
            'id',
            'username',
            'email',        # Include if needed, consider privacy
            'first_name',
            'last_name',
            'is_staff',     # Useful for frontend role checks
            'is_active',    # Useful for checking if user can log in
            'date_joined'   # Informational
         ]
        # Ensure sensitive fields are never included
        # exclude = ['password', 'user_permissions', 'groups', 'is_superuser'] # Alternative to 'fields'




